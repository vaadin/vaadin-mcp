#!/usr/bin/env node

/**
 * Vaadin Documentation MCP Server (HTTP)
 *
 * This server provides access to Vaadin documentation through the Model Context Protocol
 * using Streamable HTTP transport. It allows remote clients to search for documentation
 * and navigate hierarchical relationships between documents.
 */

import express, { type Request, type Response } from 'express';
import cors from 'cors';
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { StreamableHTTPServerTransport } from '@modelcontextprotocol/sdk/server/streamableHttp.js';
import { config } from './config.js';
import { z } from 'zod';
import { handleGetComponentsByVersionTool } from './tools/get-components-by-version/index.js';
import {
  handleGetComponentJavaApiTool,
  handleGetComponentReactApiTool,
  handleGetComponentWebComponentApiTool,
  handleGetComponentStylingTool
} from './tools/component-api/index.js';
import { handleSearchTool, handleGetFullDocumentTool } from './tools/search-and-docs/index.js';
import { handleGetVaadinVersionTool } from './tools/vaadin-version/index.js';
import { handleGetVaadinPrimerTool } from './tools/vaadin-primer/index.js';
import { LANDING_PAGE_HTML } from './tools/landing-page/index.js';

/**
 * Search result interface (legacy compatibility)
 */
export interface SearchResult {
  text: string;
  metadata: {
    title: string;
    source: string;
    url: string;
    heading?: string;
    [key: string]: any;
  };
  score: number;
}

/**
 * Create and configure MCP server instance
 */
function createMcpServer(): McpServer {
  const server = new McpServer({
    name: config.server.name,
    version: config.server.version
  });

  // Register tools using the new API
  setupTools(server);

  return server;
}

/**
 * Set up tools for the MCP server using the new registerTool API
 */
function setupTools(server: McpServer) {
  // Register get_vaadin_primer tool
  server.registerTool(
    "get_vaadin_primer",
    {
      title: "Vaadin Primer",
      description: "🚨 IMPORTANT: Always use this tool FIRST before working with Vaadin. Returns a comprehensive primer document with current (2025+) information about modern Vaadin development. This addresses common AI misconceptions about Vaadin and provides up-to-date information about Java vs React development models, project structure, components, and best practices. Essential reading to avoid outdated assumptions.",
      inputSchema: {}
    },
    async () => {
      return await handleGetVaadinPrimerTool();
    }
  );

  // Register search_vaadin_docs tool
  server.registerTool(
    "search_vaadin_docs",
    {
      title: "Search Vaadin Documentation",
      description: "Search Vaadin documentation for relevant information about Vaadin development, components, and best practices. Uses hybrid semantic + keyword search. When using this tool, try to deduce the correct development model from context: use \"flow\" for Java views, \"hilla\" for React views, or \"common\" for both. Use get_full_document with file_paths containing the result's file_path when you need complete context.",
      inputSchema: {
        question: z.string().describe("The search query or question about Vaadin. Will be used to query a vector database with hybrid search (semantic + keyword)."),
        max_results: z.number().min(1).max(20).optional().describe("Maximum number of results to return (default: 5)"),
        max_tokens: z.number().min(100).max(5000).optional().describe("Maximum number of tokens to return (default: 1500)"),
        framework: z.enum(['flow', 'hilla', 'common']).optional().describe('The Vaadin development model to focus on: "flow" for Java views, "hilla" for React views, or "common" for both. If not specified, the agent should try to deduce the correct model from context or asking the user for clarification.')
      }
    },
    async (args) => {
      return await handleSearchTool(args);
    }
  );

  // Register get_full_document tool
  server.registerTool(
    "get_full_document",
    {
      title: "Get Full Document",
      description: "Retrieves complete documentation pages for one or more file paths. Use this when you need full context beyond what search results provide. Provide file_paths only (array).",
      inputSchema: {
        file_paths: z.array(z.string()).describe("Array of file paths from search results. Use this to fetch one or more documents in a single call.")
      }
    },
    async (args) => {
      return await handleGetFullDocumentTool(args);
    }
  );

  // Register get_vaadin_version tool
  server.registerTool(
    "get_vaadin_version",
    {
      title: "Get Vaadin Version",
      description: "Returns the latest stable version of Vaadin Core as a simple JSON object. This is useful when setting up new projects, checking for updates, or when helping with dependency management. Returns: {version, released}.",
      inputSchema: {}
    },
    async () => {
      return await handleGetVaadinVersionTool();
    }
  );

  // Register get_components_by_version tool
  server.registerTool(
    "get_components_by_version",
    {
      title: "Get Components by Version",
      description: "Returns a comprehensive list of components available in a specific Vaadin version, including component names, React component names, Java class names, and npm packages.",
      inputSchema: {
        version: z.string().describe("The Vaadin version as a minor version (e.g., '24.8', '24.9', '25.0')")
      }
    },
    async (args) => {
      return await handleGetComponentsByVersionTool(args);
    }
  );

  // Register get_component_java_api tool
  server.registerTool(
    "get_component_java_api",
    {
      title: "Get Component Java API",
      description: "Returns the Java API documentation for a specific Vaadin component. The component name can be in any format (e.g., 'Button', 'button', 'vaadin-button').",
      inputSchema: {
        component_name: z.string().describe("The name of the component (e.g., 'Button', 'button', 'TextField', 'text-field')")
      }
    },
    async (args) => {
      return await handleGetComponentJavaApiTool(args);
    }
  );

  // Register get_component_react_api tool
  server.registerTool(
    "get_component_react_api",
    {
      title: "Get Component React API",
      description: "Returns the React API documentation for a specific Vaadin component. The component name can be in any format (e.g., 'Button', 'button', 'vaadin-button').",
      inputSchema: {
        component_name: z.string().describe("The name of the component (e.g., 'Button', 'button', 'TextField', 'text-field')")
      }
    },
    async (args) => {
      return await handleGetComponentReactApiTool(args);
    }
  );

  // Register get_component_web_component_api tool
  server.registerTool(
    "get_component_web_component_api",
    {
      title: "Get Component Web Component (TypeScript) API",
      description: "Returns the Web Component/TypeScript API documentation for a specific Vaadin component by fetching from external TypeScript API docs. The component name can be in any format (e.g., 'Button', 'button', 'vaadin-button').",
      inputSchema: {
        component_name: z.string().describe("The name of the component (e.g., 'Button', 'button', 'TextField', 'text-field')")
      }
    },
    async (args) => {
      return await handleGetComponentWebComponentApiTool(args);
    }
  );

  // Register get_component_styling tool
  server.registerTool(
    "get_component_styling",
    {
      title: "Get Component Styling",
      description: "Returns the styling/theming documentation for a specific Vaadin component. Returns both Java and React styling documentation when available. The component name can be in any format (e.g., 'Button', 'button', 'vaadin-button').",
      inputSchema: {
        component_name: z.string().describe("The name of the component (e.g., 'Button', 'button', 'TextField', 'text-field')")
      }
    },
    async (args) => {
      return await handleGetComponentStylingTool(args);
    }
  );
}

/**
 * Main function to start the MCP HTTP server
 */
async function startServer() {
  const app = express();
  
  // Configure CORS to support browser-based MCP clients
  app.use(cors({
    origin: '*', // Configure appropriately for production
    exposedHeaders: ['Mcp-Session-Id'],
    allowedHeaders: ['Content-Type', 'mcp-session-id'],
  }));
  
  app.use(express.json());
  
  // Health check endpoint
  app.get('/health', (req: Request, res: Response) => {
    res.json({ 
      status: 'ok', 
      server: config.server.name, 
      version: config.server.version,
      transport: 'streamable-http'
    });
  });

  // Stateless MCP endpoint
  app.post('/', async (req: Request, res: Response) => {
    try {
      // Create new server and transport instances for each request (stateless)
      const server = createMcpServer();
      const transport = new StreamableHTTPServerTransport({
        sessionIdGenerator: undefined, // Stateless mode
      });
      
      // Clean up when request is closed
      res.on('close', () => {
        console.log('Request closed');
        transport.close();
        server.close();
      });
      
      // Connect server to transport
      await server.connect(transport);
      
      // Handle the request
      await transport.handleRequest(req, res, req.body);
    } catch (error) {
      console.error('Error handling MCP request:', error);
      if (!res.headersSent) {
        res.status(500).json({
          jsonrpc: '2.0',
          error: {
            code: -32603,
            message: 'Internal server error',
          },
          id: null,
        });
      }
    }
  });

  // SSE notifications not supported in stateless mode
  app.get('/', async (req: Request, res: Response) => {
    console.log('Received GET MCP request - returning setup page');
    res.setHeader('Content-Type', 'text/html');
    res.send(LANDING_PAGE_HTML);
  });

  // Legacy MCP endpoint - inform about new URL
  app.get('/mcp', (req: Request, res: Response) => {
    res.status(404).json({
      error: 'Not Found',
      message: 'The MCP server has moved. The new URL is https://mcp.vaadin.com/docs',
      oldUrl: 'https://mcp.vaadin.com/docs/mcp',
      newUrl: 'https://mcp.vaadin.com/docs',
      timestamp: new Date().toISOString()
    });
  });

  // Session termination not needed in stateless mode
  app.delete('/', async (req: Request, res: Response) => {
    console.log('Received DELETE MCP request');
    res.writeHead(405).end(JSON.stringify({
      jsonrpc: "2.0",
      error: {
        code: -32000,
        message: "Method not allowed. This server operates in stateless mode."
      },
      id: null
    }));
  });

  // Start the server
  const port = config.server.httpPort;
  app.listen(port, () => {
    console.log(`🚀 Vaadin Documentation MCP Server (HTTP) listening on port ${port}`);
    console.log(`📍 MCP endpoint: http://localhost:${port}/`);
    console.log(`🏥 Health check: http://localhost:${port}/health`);
    console.log(`🔧 Transport: Streamable HTTP (stateless mode)`);
    console.log(`🔗 REST Server: ${config.restServer.url}`);
  });

  // Graceful shutdown
  process.on('SIGINT', () => {
    console.log('\n🛑 Received SIGINT, shutting down gracefully...');
    process.exit(0);
  });

  process.on('SIGTERM', () => {
    console.log('\n🛑 Received SIGTERM, shutting down gracefully...');
    process.exit(0);
  });
}

// Start the server
startServer().catch((error) => {
  console.error('❌ Failed to start MCP server:', error);
  process.exit(1);
});